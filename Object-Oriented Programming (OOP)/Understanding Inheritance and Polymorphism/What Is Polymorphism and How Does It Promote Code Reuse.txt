Polymorphism is the next key concept of object-oriented programming (OOP) we will talk about.

With polymorphism, you have access to an interface where you can interact with many objects of the same kind.

Let's take a deeper look at polymorphism and how it lets you reuse code.

Polymorphism allows methods in different classes to share the same name but perform different tasks. You call the same method name on different objects, and each responds in its own way.

Here's the basic example of polymorphism:

class A:
   def action(self): ...

class B:
   def action(self): ...

class C:
   def action(self): ...

Class().method()  # Works for A, B, or C
Here's an example using different animal sounds to depict polymorphism:

class Cat:
   def speak(self):
       return "A cat meow"

class Bird:
   def speak(self):
       return "A bird tweet"
  
class Monkey:
   def speak(self):
       return "A monkey ooh ooh aah aah ooh ooh aah aah"

def animal_sound(animal):
   print(animal.speak())

animal_sound(Cat())
animal_sound(Bird())
animal_sound(Monkey())
In this example, animal_sound() is a function that takes any object with a speak() method. 

When you pass in a Cat, Bird, or Monkey, it calls the speak() method of the object and prints the result. Because each class defines speak() differently, you get different outputs from the same function. That's polymorphism in action.

Here's another example, this time with instances and an attribute:

class Twitter:
   def __init__(self, content):
       self.content = content

   def post(self):
       return f"üê¶ Tweet: '{self.content}' (280 chars max)"

class Instagram:
   def __init__(self, content):
       self.content = content

   def post(self):
       return f"üì∏ Instagram Post: '{self.content}' + ‚ú® filters"

class LinkedIn:
   def __init__(self, content):
       self.content = content

   def post(self):
       return f"üíº LinkedIn Article: '{self.content}' (Professional Mode)"

def start(social_media):
   print(social_media.post())  # Calls .post() on any object

# Instances
tweet = Twitter('Just learned Python polymorphism!')
photo = Instagram('Sunset vibes üåÖ')
article = LinkedIn('Why OOP matters in 2024')

# The polymorphic calls - same function, different outputs
start(tweet) # üê¶ Tweet: 'Just learned Python polymorphism!' (280 chars max)
start(photo) # üì∏ Instagram Post: 'Sunset vibes üåÖ' + ‚ú® filters
start(article) # üíº LinkedIn Article: 'Why OOP matters in 2024' (Professional Mode)
There's also a kind of polymorphism called inheritance-based polymorphism.

In inheritance-based polymorphism, a parent class defines a method, and multiple child classes override that method in their own way. You can then call the same method on any child object, and it behaves differently depending on which child class it is.

Here's an example:

class Animal:
   def speak(self):
       return 'Some generic sound'

class Cat(Animal):
   def speak(self):
       return 'A cat meow'

class Dog(Animal):
   def speak(self):
       return 'A dog barks woof woof'

class Monkey(Animal):
   def speak(self):
       return 'A monkey ooh ooh aah aah ooh ooh aah aah'
  
print(Cat().speak()) # A cat meow
print(Dog().speak()) # A dog barks woof woof
print(Monkey().speak()) # A monkey ooh ooh aah aah ooh ooh aah aah
print(Animal().speak()) # Some generic sound
You can see that each child class of the parent Animal class overrides the speak() method to provide its own implementation. So when you call the speak() method on an instance of each subclass, it returns the specific sound associated with that animal.

You can also take things further and do the calling in a list, then loop through the list to display what the speak() method returns for each:

animals = [Cat(), Dog(), Monkey()]

for animal in animals:
   print(animal.speak())

# Output:
# A cat meow
# A dog barks woof woof
# A monkey ooh ooh aah aah ooh ooh aah aah
